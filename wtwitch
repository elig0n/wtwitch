#!/bin/bash
#
# Description: Browse and watch Twitch without being tracked.
#
# Homepage: https://gitlab.com/krathalan
#
# Copyright (C) 2019 krathalan
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# ------------------
# --- Guidelines ---
# ------------------

# This script follows the Google Shell Style Guide: 
# https://google.github.io/styleguide/shell.xml

# This script uses shellcheck: https://www.shellcheck.net/

# This script spawns subshell processes (see check_twitch_streams function)
trap "clean_up && kill 0" SIGINT

# See https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
set -Eeuo pipefail

# -----------------------------------------
# ----------- Program variables -----------
# -----------------------------------------

# Colors
readonly GREEN=$(tput bold && tput setaf 2)
readonly RED=$(tput bold && tput setaf 1)
readonly ORANGE=$(tput setaf 3)
readonly TURQOISE=$(tput setaf 6)
readonly NC=$(tput sgr0) # No color/turn off all tput attributes

readonly CACHE_EXPIRY_TIME="60" # In seconds
readonly CACHE_FILE_DIRECTORY="${HOME}/.cache/wtwitch"
readonly CACHE_OFFLINE_TEXT_FILE="${CACHE_FILE_DIRECTORY}/.stream_offline.txt"
readonly CACHE_ONLINE_TEXT_FILE="${CACHE_FILE_DIRECTORY}/.stream_online.txt"
readonly CHECK_MARK="${GREEN}✔${NC}"
readonly CONFIG_FILE_DIRECTORY="${HOME}/.config/wtwitch"
readonly CONFIG_FILE="${CONFIG_FILE_DIRECTORY}/config.json"
readonly SCRIPT_NAME=$(basename "$0")
readonly TWITCH_API_URL="https://api.twitch.tv"

# -----------------------------------------
# ------------- User variables ------------
# -----------------------------------------

# Values are loaded from ~/.config/wtwitch/config.json
userPlayer=""
userQuality=""
userSubscriptions=()

# -----------------------------------------
# --------------- Functions ---------------
# -----------------------------------------

#######################################
# Changes the default player in ~/.config/wtwitch/config.json that 
# gets passed to streamlink.
# Globals:
#   ORANGE, NC, CHECK_MARK
#   CONFIG_FILE
# Arguments:
#   $1: player to set as default
# Returns:
#   none
#######################################
change_player()
{
  # Convert to lowercase
  local -r playerName="${1,,}"
  local -r workingPlayers=("gnome-mpv" "mpv" "mplayer" "vlc")
  local passedCheckMarker="false"

  check_command "${playerName}"

  # Check against known working players
  for i in "${workingPlayers[@]}"; do
    if [[ "${playerName}" == "${i}" ]]; then
      passedCheckMarker="true"
    fi
  done

  if [[ "${passedCheckMarker}" != "true" ]]; then
    printf "\n %sWarning%s: player %s may not work properly with Streamlink.\n" "${ORANGE}" "${NC}" "${playerName}"
  fi

  write_setting ".player" "${playerName}"
  printf "\n %s Successfully changed default player to %s.\n" "${CHECK_MARK}" "${playerName}"
}

#######################################
# Changes the default quality in ~/.config/wtwitch/config.json that 
# gets passed to streamlink.
# Globals:
#   CHECK_MARK
#   CONFIG_FILE
# Arguments:
#   $1: quality to set as default
# Returns:
#   none
#######################################
change_quality()
{
  # Convert to lowercase
  local -r specifiedQuality="${1,,}"
  local -r acceptableQualities=("worst" "160p" "360p" "480p" "720p" "720p60" "1080p60" "best")
  local passedCheckMarkerArray=()

  # User may try and enter fallback qualities; we should account for this
  IFS=',' read -r -a qualityArray <<< "$specifiedQuality"

  # For each quality the user has specified
  for i in "${qualityArray[@]}"; do
    # Check to make sure it's an acceptable quality
    for j in "${acceptableQualities[@]}"; do
      if [[ "${i}" == "${j}" ]]; then
        passedCheckMarkerArray+=("true")
      fi
    done
  done

  # Make sure there are an equal number of "true" elements in passedCheckMarkers as there are qualities in specifiedQuality
  if [[ ${#qualityArray[@]} -eq ${#passedCheckMarkerArray[@]} ]]; then
    write_setting ".quality" "${specifiedQuality}"
    printf "\n %s Successfully changed default quality to %s.\n" "${CHECK_MARK}" "${specifiedQuality}"
  else
    exit_script_on_failure "Quality ${specifiedQuality} is not an acceptable quality. See https://gitlab.com/krathalan/wtwitch#wtwitch-q-quality-change-qualityquality for more information."
  fi
}

#######################################
# Checks to see if a specified command is available.
# Globals:
#   none
# Arguments:
#   $1: command to test
# Returns:
#   none
#######################################
check_command()
{
  if [[ ! -x "$(command -v "$1")" ]]; then
        exit_script_on_failure "Package $1 not installed. More information: https://gitlab.com/krathalan/wtwitch#dependencies"
  fi
}

#######################################
# Checks to see which subscribed Twitch streams are online
# and prints the user's settings.
# Globals:
#   CONFIG_FILE
#   userSubscriptions
#   CACHE_ONLINE_TEXT_FILE
#   CACHE_OFFLINE_TEXT_FILE
# Arguments:
#   none
# Returns:
#   none
#######################################
check_twitch_streams()
{
  printf "\n Streamers online:"

  # Check cache expiry time
  local dateDiff="0"
  local lastSubscriptionUpdate
  lastSubscriptionUpdate=$(jq -r ".lastSubscriptionUpdate" "${CONFIG_FILE}")

  if [[ "${lastSubscriptionUpdate}" != "null" ]]; then
    local -r currentDate=$(date +%s -d "now")
    lastSubscriptionUpdate=$(date +%s -d "${lastSubscriptionUpdate}")
    dateDiff=$(( currentDate - lastSubscriptionUpdate ))
  fi

  if  [[ "${lastSubscriptionUpdate}" == "null" ]] || [[ $dateDiff -gt $CACHE_EXPIRY_TIME ]] \
  || [[ ! -f "${CACHE_ONLINE_TEXT_FILE}" ]] || [[ ! -f "${CACHE_OFFLINE_TEXT_FILE}" ]]; then
    # Remove old cache files
    clean_up

    # Ensure that both CACHE_ONLINE_TEXT_FILE and CACHE_OFFLINE_TEXT_FILE get written to;
    # sometimes all streamers are online or offline
    touch "${CACHE_ONLINE_TEXT_FILE}" && touch "${CACHE_OFFLINE_TEXT_FILE}"

    for stream in "${userSubscriptions[@]}"; do
      (check_twitch_streams_helper "${stream}") &
    done

    wait

    # Update lastSubscriptionUpdate time
    local -r subscriptionUpdateTime=$(date -d "now")
    write_setting ".lastSubscriptionUpdate" "${subscriptionUpdateTime}"
  fi
  
  printf "\n"

  if [[ -f "${CACHE_ONLINE_TEXT_FILE}" ]]; then
    sort "${CACHE_ONLINE_TEXT_FILE}" 2> /dev/null
  fi

  printf "\n Streamers offline:\n"

  if [[ -f "${CACHE_OFFLINE_TEXT_FILE}" ]]; then
    sort "${CACHE_OFFLINE_TEXT_FILE}" 2> /dev/null
  fi

  printf "\n Settings:"
  printf "\n   Player set to %s" "${userPlayer}"
  printf "\n   Quality set to %s\n" "${userQuality}"
}

#######################################
# Used by check_twitch_streams to facilitate multi-process
# fetching and parsing of Twitch json files.
# Globals:
#   RED, NC, TURQOISE, ORANGE
#   TWITCH_API_KEY
#   TWITCH_API_URL
#   CACHE_ONLINE_TEXT_FILE
#   CACHE_OFFLINE_TEXT_FILE
# Arguments:
#   none
# Returns:
#   none
#######################################
check_twitch_streams_helper()
{
  # Get current info of streamer
  local -r streamerJson=$(curl --silent -H "Client-ID: ${TWITCH_API_KEY}" -X GET "${TWITCH_API_URL}/kraken/streams/$1")

  local streamType
  streamType=$(jq -r ".stream.stream_type" <<< "${streamerJson}")

  # Check if stream is online 
  if [[ "${streamType}" != "null" ]]; then
    local -r playingGame=$(jq -r ".stream.game" <<< "${streamerJson}")

    local streamName
    streamName=$(jq -r ".stream.channel.status" <<< "${streamerJson}")

    # Truncate stream name if necessary; some streamers have excessively long stream titles
    local streamNameLength=${#streamName}

    if [[ "${streamNameLength}" -gt 50 ]]; then
      streamName=$(printf "%s" "${streamName}" | cut -c 1-50)
      streamName="${streamName}…"
    fi

    if [[ "${streamType}" == "live" ]]; then
      streamType=""
    else
      streamType=", ${RED}${streamType}${NC}"
    fi

    printf "   %s%s%s: %s %s(playing %s%s%s)%s\n" "${TURQOISE}" "$1" "${NC}" "${streamName}" "${ORANGE}" "${playingGame}" "${streamType}" "${ORANGE}" "${NC}" >> "${CACHE_ONLINE_TEXT_FILE}"
  else
    printf "   %s%s%s\n" "${TURQOISE}" "$1" "${NC}" >> "${CACHE_OFFLINE_TEXT_FILE}"
  fi
}

#######################################
# Cleans up temporary file(s).
# Globals:
#   CACHE_ONLINE_TEXT_FILE
#   CACHE_OFFLINE_TEXT_FILE
# Arguments:
#   none
# Returns:
#   none
#######################################
clean_up()
{
  # Clean up
  rm -f "${CACHE_ONLINE_TEXT_FILE}"
  rm -f "${CACHE_OFFLINE_TEXT_FILE}"
}

#######################################
# Prints passed error message before premature exit.
# Prints everything to >&2 (STDERR).
# Globals:
#   RED, NC
#   SCRIPT_NAME
# Arguments:
#   $1: error message to print
# Returns:
#   none
#######################################
exit_script_on_failure() {
  if [[ $# -gt 0 ]]; then
    printf "\n %sError%s: %s\n" "${RED}" "${NC}" "$1" >&2
    printf "\n Exiting %s Bash script.\n" "${SCRIPT_NAME}" >&2
  fi
  
  clean_up
  exit 1
}

#######################################
# Lists the top streamers for a specified game.
# Globals:
#   TURQOISE, NC, ORANGE
#   TWITCH_API_KEY
#   TWITCH_API_URL
# Arguments:
#   $1: game to list top streamers of
# Returns:
#   none
#######################################
list_streamers_of_game()
{
  # Replace spaces in game name with %20
  local -r gameName=${1// /%20}

  # Get game_id
  local twitchJson
  twitchJson=$(curl --silent -H "Client-ID: ${TWITCH_API_KEY}" -X GET "${TWITCH_API_URL}/helix/games?name=${gameName}")
  
  local -r gameID=$(jq -r ".data[0].id" <<< "${twitchJson}")

  # Get streamers
  twitchJson=$(curl --silent -H "Client-ID: ${TWITCH_API_KEY}" -X GET "${TWITCH_API_URL}/helix/streams?game_id=${gameID}")

  local streamerName=""
  streamerName=$(jq -r ".data[0].user_name" <<< "${twitchJson}")

  local streamTitle=""
  streamTitle=$(jq -r ".data[0].title" <<< "${twitchJson}")

  local viewers=""
  viewers=$(jq -r ".data[0].viewer_count" <<< "${twitchJson}")

  local streamTitleLength

  printf "\n %s streamers:\n" "$1"

  local whileCounter=1

  while [[ "${streamerName}" != "null" ]]; do
    # Truncate title if necessary
    streamTitleLength=${#streamTitle}

    if [[ "${streamTitleLength}" -gt 50 ]]; then
      streamTitle=$(printf "%s" "${streamTitle}" | cut -c 1-50)
      streamTitle="${streamTitle}…"
    fi

    printf "   %s%s%s: %s %s(%s viewers)%s\n" "${TURQOISE}" "${streamerName}" "${NC}" "${streamTitle}" "${ORANGE}" "${viewers}" "${NC}"

    # Refresh data
    streamerName=$(jq -r ".data[${whileCounter}].user_name" <<< "${twitchJson}")
    streamTitle=$(jq -r ".data[${whileCounter}].title" <<< "${twitchJson}")
    viewers=$(jq -r ".data[${whileCounter}].viewer_count" <<< "${twitchJson}")
    whileCounter=$(( whileCounter + 1 ))
  done
}

#######################################
# Lists the top games on Twitch.
# Globals:
#   TURQOISE, NC
#   TWITCH_API_KEY
#   TWITCH_API_URL
# Arguments:
#   none
# Returns:
#   none
#######################################
list_top_games()
{
  printf "\n Top games:\n"
  
  local -r twitchJson=$(curl --silent -H "Client-ID: ${TWITCH_API_KEY}" -X GET "${TWITCH_API_URL}/helix/games/top")

  local gameName=""
  gameName=$(jq -r ".data[0].name" <<< "${twitchJson}")

  local whileCounter=1

  while [[ "${gameName}" != "null" ]]; do
    printf "   %s. %s%s%s\n" "${whileCounter}" "${TURQOISE}" "${gameName}" "${NC}"

    # Refresh data
    gameName=$(jq -r ".data[${whileCounter}].name" <<< "${twitchJson}")
    whileCounter=$(( whileCounter + 1 ))
  done
}

#######################################
# Loads user configuration from ~/.config/wtwitch/config.json.
# Globals:
#   CONFIG_FILE
#   CONFIG_FILE_DIRECTORY
#   userPlayer
#   userQuality
#   userSubscriptions
# Arguments:
#   none
# Returns:
#   none
#######################################
load_config()
{
  # Create config file if it doesnt exist
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    if [[ ! -d "${CONFIG_FILE_DIRECTORY}" ]]; then
      mkdir "${CONFIG_FILE_DIRECTORY}"
    fi
    printf "{\"player\": \"mpv\",\"quality\": \"best\",\"subscriptions\": []}" > "${CONFIG_FILE}"
  fi

  # Create cache folder if it doesn't exist
  if [[ ! -d "${CACHE_FILE_DIRECTORY}" ]]; then
    mkdir "${CACHE_FILE_DIRECTORY}"
  fi

  # Player
  userPlayer=$(jq -r ".player" "${CONFIG_FILE}")

  # Quality
  userQuality=$(jq -r ".quality" "${CONFIG_FILE}")

  # Subscriptions
  local currentSubscription
  currentSubscription=$(jq -r ".subscriptions[0].streamer" "${CONFIG_FILE}")

  local whileCounter=1

  while [[ "${currentSubscription}" != "null" ]]; do
    userSubscriptions+=("${currentSubscription}")

    # Refresh data
    currentSubscription=$(jq -r ".subscriptions[${whileCounter}].streamer" "${CONFIG_FILE}")
    whileCounter=$(( whileCounter + 1 ))
  done
}

#######################################
# Prints information about how to use this script.
# Globals:
#   GREEN, NC
#   SCRIPT_NAME
# Arguments:
#   none
# Returns:
#   none
#######################################
print_help()
{
  local copyrightDate
  copyrightDate=$(date +%Y -d "now")

  if [[ ! ${copyrightDate} -eq 2019 ]]; then
    copyrightDate="2019-${copyrightDate}"
  fi

  printf "\n %s%s%s - browse and watch Twitch streams without being tracked.\n" "${GREEN}" "${SCRIPT_NAME}" "${NC}"
  printf " Copyright (C) %s krathalan\n" "${copyrightDate}"
  printf " This is free software: you are free to change and redistribute it.\n"
  printf " There is NO WARRANTY, to the extent permitted by law.\n\n"
  printf " Homepage: https://gitlab.com/krathalan/wtwitch\n\n"
  printf " Usage: bash %s [OPTION] [ARG]\n\n" "${SCRIPT_NAME}"
  printf " Options:\n"

  print_help_helper "-h, --help" "show this help" "bash wtwitch -h"
  print_help_helper "(no option) [STREAMER]" "watch the specified streamer" "bash wtwitch overwatchleague"
  print_help_helper "-c, --check" "view which subscribed Twitch streams are online and your settings" "bash wtwitch -c"
  print_help_helper "-g [GAME], --get-streamers=[GAME]" "view the top streamers for a specified game" "bash wtwitch -g \"world of warcraft\""
  print_help_helper "-p [PLAYER], --change-player=[PLAYER]" "changes the default player in ~/.config/wtwitch/config.json that gets passed to Streamlink" "bash wtwitch -p gnome-mpv"
  print_help_helper "-q [QUALITY], --change-quality=[QUALITY]" "changes the default quality in ~/.config/wtwitch/config.json that gets passed to Streamlink" "bash wtwitch -q \"720p,480p\""
  print_help_helper "-s [STREAMER], --subscribe=[STREAMER]" "subscribes to a specific streamer" "bash wtwitch -s overwatchleague"
  print_help_helper "-t, --top-games" "lists the top games on twitch" "bash wtwitch -t"
  print_help_helper "-u [STREAMER], --unsubscribe=[STREAMER]" "unsubscribes from a specified streamer" "bash wtwitch -u overwatchleague"
}

#######################################
# Formats strings nicely for print_help().
# Globals:
#   NC, TURQOISE, ORANGE
# Arguments:
#   $1: option
#   $2: description of option
#   $3: example usage of option
# Returns:
#   none
#######################################
print_help_helper()
{
  local -r description="Description: "${NC}
  local -r usage="Usage: "
  printf "   %s%s%s\n     %s%s%s%s\n     %s%s%s%s\n" "${TURQOISE}" "$1" "${NC}" "${ORANGE}" "${description}" "${NC}" "$2" "${ORANGE}" "${usage}" "${NC}" "$3"
}

#######################################
# Opens a stream with Streamlink.
# Globals:
#   TWITCH_API_KEY
#   TWITCH_API_URL
#   userPlayer
#   userQuality
# Arguments:
#   $1: name of streamer to watch
# Returns:
#   none
#######################################
stream()
{
  # Check to make sure streamer is online 
  # Get current info of streamer
  local -r streamerJson=$(curl --silent -H "Client-ID: ${TWITCH_API_KEY}" -X GET "${TWITCH_API_URL}/kraken/streams/$1")

  local -r streamType=$(jq -r ".stream.stream_type" <<< "${streamerJson}")

  if [[ "${streamType}" == "null" ]]; then
    notify-send -i "gnome-twitch" "Wtwitch: streaming $1 failed" "Streamer $1 is not online."
    exit_script_on_failure
  fi

  # Add title and enable hardware decoding if using mpv
  if [[ "${userPlayer}" == "mpv" ]]; then
  {
    {
      # Try
      streamlink --player-continuous-http -p "${userPlayer} --hwdec=auto" --title "Watching $1 on Twitch (${userQuality})" --twitch-disable-ads "https://www.twitch.tv/$1" "${userQuality}" 2> /dev/null
    } || {
      # Catch
      notify-send -i "gnome-twitch" "Wtwitch: streaming $1 failed" "It's possible that $1's stream does not support quality ${userQuality}."
      exit_script_on_failure
    }
  }
  else
  {
    {
      # Try
      streamlink --player-continuous-http -p "${userPlayer}" --twitch-disable-ads "https://www.twitch.tv/$1" "${userQuality}" 2> /dev/null
    } || {
      # Catch
      notify-send -i "gnome-twitch" "Wtwitch: streaming $1 failed" "It's possible that $1's stream does not support quality ${userQuality}."
      exit_script_on_failure
    }
  }
  fi
}

#######################################
# Subscribes to a specific streamer.
# Globals:
#   CHECK_MARK
#   CONFIG_FILE
#   TWITCH_API_KEY
#   TWITCH_API_URL
# Arguments:
#   $1: streamer to subscribe to
# Returns:
#   none
#######################################
subscribe()
{
  # Convert to lowercase
  local -r streamerToSubscribeTo="${1,,}"

  # Check to make sure user isn't already subscribed
  local -r subscriptionArrayLength=$(jq ".subscriptions | length" "${CONFIG_FILE}")

  if [[ ${subscriptionArrayLength} -gt 0 ]]; then
    local currentSubscription
    currentSubscription=$(jq -r ".subscriptions[0].streamer" "${CONFIG_FILE}")

    local whileCounter=1

    while [[ "${currentSubscription}" != "null" ]] && [[ "${currentSubscription}" != "${streamerToSubscribeTo}" ]]; do
      # Refresh data
      currentSubscription=$(jq -r ".subscriptions[$whileCounter].streamer" "${CONFIG_FILE}")
      whileCounter=$(( whileCounter + 1))
    done

    if [[ "${currentSubscription}" == "${streamerToSubscribeTo}" ]]; then
      exit_script_on_failure "You are already subscribed to ${streamerToSubscribeTo}."
    fi
  fi

  # Check to make sure streamer exists before subscribing
  local -r streamerJson=$(curl --silent -H "Client-ID: ${TWITCH_API_KEY}" -X GET "${TWITCH_API_URL}/kraken/channels/${streamerToSubscribeTo}")
  local -r streamerStatus=$(jq -r ".status" <<< "${streamerJson}")

  if [[ "${streamerStatus}" == "404" ]]; then
    exit_script_on_failure "Streamer ${streamerToSubscribeTo} does not exist."
  fi

  # Add subscription
  local -r tempJson=$(jq ".subscriptions[.subscriptions | length] |= . + {\"streamer\":\"$streamerToSubscribeTo\"}" "${CONFIG_FILE}")
  printf "%s" "${tempJson}" > "${CONFIG_FILE}"

  # Invalidate cache
  write_setting ".lastSubscriptionUpdate" "null"

  printf "\n %s Successfully subscribed to %s.\n" "${CHECK_MARK}" "${streamerToSubscribeTo}"
}

#######################################
# Unsubscribes from a specific streamer.
# Globals:
#   CONFIG_FILE
#   CHECK_MARK
# Arguments:
#   $1: streamer to unsubscribe from
# Returns:
#   none
#######################################
unsubscribe()
{
  # Convert to lowercase
  local -r streamerToUnsubscribeFrom="${1,,}"

  # Find index of streamer in .subscriptions[]
  local currentSubscription
  currentSubscription=$(jq -r ".subscriptions[0].streamer" "${CONFIG_FILE}")

  local whileCounter=1

  while [[ "${currentSubscription}" != "$streamerToUnsubscribeFrom" ]] && [[ "${currentSubscription}" != "null" ]]; do
    # Refresh data
    currentSubscription=$(jq -r ".subscriptions[${whileCounter}].streamer" "${CONFIG_FILE}")
    whileCounter=$(( whileCounter + 1 ))
  done

  whileCounter=$(( whileCounter - 1 ))

  # Check to make sure user is subscribed before unsubscribing
  local -r subscriptionArrayLength=$(jq ".subscriptions | length" "${CONFIG_FILE}")

  if [[ ! $whileCounter -lt $subscriptionArrayLength ]]; then
    exit_script_on_failure "You weren't subscribed to ${streamerToUnsubscribeFrom} in the first place."
  fi

  # Remove subscription
  local -r tempJson=$(jq "del(.subscriptions[${whileCounter}])" "${CONFIG_FILE}")
  printf "%s" "${tempJson}" > "${CONFIG_FILE}"

  # Invalidate cache
  write_setting ".lastSubscriptionUpdate" "null"
  printf "\n %s Successfully unsubscribed from %s.\n" "${CHECK_MARK}" "${streamerToUnsubscribeFrom}"
}

#######################################
# Writes a setting value to the config file.
# Globals:
#   CONFIG_FILE
# Arguments:
#   $1: key
#   $2: value
# Returns:
#   none
#######################################
write_setting()
{
  local -r tempJson=$(jq "$1 = \"$2\"" "${CONFIG_FILE}")
  printf "%s" "${tempJson}" > "${CONFIG_FILE}"
}

# --------------------------------------
# --------------- Script ---------------
# --------------------------------------

check_command "curl"
check_command "jq"
load_config

if [[ $# -eq 0 ]]; then
  print_help
  exit 0
fi

# Parse flags. From:
# https://stackoverflow.com/questions/7069682/how-to-get-arguments-with-flags-in-bash/7069755#7069755
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      print_help
      exit 0
      break
      ;;
    -c|--check)
      check_twitch_streams
      exit 0
      break
      ;;
    -g)
      shift
      if [[ $# -gt 0 ]]; then
        list_streamers_of_game "$1"
        exit 0
      else
        exit_script_on_failure "No game specified."
      fi
      break
      ;;
    --get-streamers*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        gameToCheck=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        list_streamers_of_game "${gameToCheck}"
      else
        exit_script_on_failure "No game specified."
      fi
      exit 0
      break
      ;;
    -p)
      shift
      if [[ $# -gt 0 ]]; then
        change_player "$1"
        exit 0
      else
        exit_script_on_failure "No media player specified."
      fi
      break
      ;;
    --change-player*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        player=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        change_player "${player}"
      else
        exit_script_on_failure "No media player specified."
      fi
      exit 0
      break
      ;;
    -q)
      shift
      if [[ $# -gt 0 ]]; then
        change_quality "$1"
        exit 0
      else
        exit_script_on_failure "No quality specified."
      fi
      break
      ;;
    --change-quality*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        quality=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        change_quality "${quality}"
      else
        exit_script_on_failure "No quality specified."
      fi
      exit 0
      break
      ;;
    -s)
      shift
      if [[ $# -gt 0 ]]; then
        subscribe "$1"
        exit 0
      else
        exit_script_on_failure "No streamer specified."
      fi
      break
      ;;
    --subscribe*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        streamerToSubscribeTo=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        subscribe "${streamerToSubscribeTo}"
      else
        exit_script_on_failure "No streamer specified."
      fi
      exit 0
      break
      ;;
    -t|--top-games)
      list_top_games
      exit 0
      break
      ;;
    -u)
      shift
      if [[ $# -gt 0 ]]; then
        unsubscribe "$1"
        exit 0
      else
        exit_script_on_failure "No streamer specified."
      fi
      break
      ;;
    --unsubscribe*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        streamerToUnsubscribeFrom=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        unsubscribe "${streamerToUnsubscribeFrom}"
      else
        exit_script_on_failure "No streamer specified."
      fi
      exit 0
      break
      ;;
    *)
      break
      ;;
  esac
done

if [[ ! -x "$(command -v "${userPlayer}")" ]]; then
  if [[ -x "$(command -v "vlc")" ]]; then
    printf "\n %s not found. Using VLC instead...\n" "${userPlayer}"
    userPlayer="vlc"
  else
    exit_script_on_failure "Media player ${userPlayer} not found."
  fi
fi

check_command "streamlink"
(stream "$1" > /dev/null) &